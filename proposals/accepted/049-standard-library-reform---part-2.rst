Standard library reform -- Part 2
=================================

.. sectnum::
.. contents::

Abstract
--------

*This is the remainder of `Proposal 47 <https://github.com/haskellfoundation/tech-proposals/pull/47>`.
I have no intention of formally proposing these parts any time soon --- not until the first proposal is accepted and close to complete, at least --- but am nonetheless opening an additional proposal now so both can be linked to one another for additional context.*

Issues with the standard library are holding back the Haskell ecosystem.
The problems and solutions are multifaceted, and so the Haskell Foundation in its "umbrella organization" capacity is uniquely suited to coordinate the fixing of them.

The remaining problems are briefly as follows:

#. Done! (TODO don't rely on positional numbering.)

#. Major version bumps every compiler release is a nuisance.

#. No clear portability guarantees with new supported platforms like the web browser and Web Assembly System Interface (WASI).

#. Breaking changes (when we do want them) have to be coupled with GHC versions rather than staggered, which is painful.

#. Popular and uncontroversial machinery like ``Text`` is not available from the standard library.

By reshuffling our interfaces and implementations alike, we should be able to solve all these problems.

.. _`CLC Issue #105`: https://github.com/haskell/core-libraries-committee/issues/105

Problem Statement
-----------------

**Problem 2**: Major version bumps every compiler release
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Currently, every major release of of GHC is accompanied with a major version of ``base``, and also other libraries like ``template-haskell``.
This causes numerous issues:

First and foremost, these major version bumps create a ton of busywork to upgrade to a new version of GHC as library version requirements must be relaxed.

Secondly they undermine our other processes by creating perverse incentives.

Library authors find it convenient to make too-loose requirements on ``base`` on the assumption that whatever base breakage happens next "probably" won't effect them.
But fast-and-loose version bounds undermine the version solver, which can no longer be trusted to choose good plans in that scenario.
We want version solving to be sound and complete, and the only way for that to be the case is if breaking changes are infrequent enough that people do not feel the urge to do this.

These major version bumps also make it harder to think about compatibility and ease of upgrading with GHC in general.
This and other long-shrugged-off paper cuts during the upgrade process result in a big picture where where some of us are numb to breakage, and others are irate about it.
We should do the little things well so the remaining thornier issues around GHC upgrading (syntax changes, type system changes, etc.) can be approached from a "decluttered" starting point.

Solution criteria
^^^^^^^^^^^^^^^^^

Users should usually be able to upgrade to the next GHC version without adjusting any library version requirements.

**Problem 3**: No clear portability guarantees with new targets
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The new compilation backends that come with GHC 9.6 correspond, strictly speaking, to new supported CPUs/Arches, like "x86" vs "Aarch64" vs "RISC-V", etc.
WASM and JS are, with enough squinting, just other ways of expressing computation: ways which should by and large not leak to the user. [#cpu-leaks]_

What is more interesting from a library design perspective is over what *software* will the code be run.
This would be analogous to the "Operating Systems" part of the platform description, like "Linux" vs "Windows" vs "macOS" etc.

JavaScript generated by GHC can be run in two places:

- The web browser
- Node.js and similar projects

WASM can also be run in two places:

- The web browser
- Wasmtime and similar projects

Node.js exposes as much of the underlying functionality of the OS as it can, and so a standard library with it in mind doesn't need to be that different from a standard library with the underlying OS in mind.
The other two, however are a radical departure:

- The web browser is nothing at all like Unix.

- WASI, the Web Assembly System Interface, is like a "functional unix" removing ambient authority and forcing side effects to be mediated via file descriptors.
  The upcoming `WASI Component Model <https://github.com/WebAssembly/component-model>`_ also plans on creating replacements for some "stringly typed" Unix functionality with "richly typed" interfaces.
  Both these things are an *excellent* fit for Haskell.

The existing implementations in GHC duck-tape over ``base`` and friends the best they can to get something working.
That is to say, we have some CPP::

  $ git grep js_HOST_ARCH libraries/ | wc-l
  52

  $ git grep wasm32_HOST_ARCH libraries/ | wc -l
  2

This made perfect sense for GHCJS, and perfect sense for just getting things going more broadly.
But they are poor long-term choices for a mature, first-class backend.

A first issue is that since this is all based on the host *arch* and not *OS*, we have no distinguishing between the browser and non-browser runtimes.
One just has to hope that the intended deployment environment as the functionality they wish to use.

A second issue is that it is very easy to, when developing (say with GHCi or HLS) on one platform, accidentally depend on things that not available on the other platforms ones wishes to support.
Yes, CI which builds for all of the platforms can and should catch this, but it is always sub-optimal to only catch basic issues then.

The much lower CPP count for Web Assembly reflects that fact that the reference `WASI libc`_ itself tries to emulate POSIX the best it can.
But this just means the same infelicities are there, just less directly observable.
For example, it incorporates the techniques of `libpreopen`_ to simulate ambient authority such as opening arbitrary files by absolute path.
But best-effort techniques like this only if one is lucky; they are a great way for adapting *existing* applications but a *poor* way for writing new greenfield ones.

.. _`WASI libc`: https://github.com/WebAssembly/wasi-libc
.. _`libpreopen`: https://github.com/musec/libpreopen

Solution criteria
^^^^^^^^^^^^^^^^^

Projects should be able to depend on libraries that just expose functionality that is known to work on the platform(s) they run on.
The plural, "platforms" is key.
Projects that wish to support some subset of Unix, Windows, Web, and WASI must be able to depend on libraries that only offer the *intersection* of what works on each of those, i.e. what works on all of them.
We will thus need more than one standard library.

Platform-specific functionality should be exposed in ways that make sense in Haskell, not C.
Traditional libc idioms and "lowest common denominator" practice should be skipped when it does not make sense in a Haskell context.
It should be possible to use WASM and WASI without any "libc".

**Problem 4**: Breaking changes have to coupled, not staggered, with GHC versions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Wishful thinking would have it that we can just *stop* doing breaking changes, forever.
But requirements change, and mistakes are made.
Issues will arise in the standard library and we will wish to fix them, because whatever the cost is to existing programs (which we can still attempt to mitigate) is outweighed by the benefit to future programs.

However, if the standard library version is tied to GHC version, we have no choice but to do the breaking change coupled with a compiler version.
Gabriella Gonzalez laid out the case in `Release early and often <https://www.haskellforall.com/2019/05/release-early-and-often.html>`_ on why coupling changes, especially breaking changes, together is bad, and I will cite that rather than restate the argument.
For those reasons we shouldn't do that here with the standard library and GHC.

Solution criteria
^^^^^^^^^^^^^^^^^

Changes in the standard library in the compiler should always be staggered.
It should be possible to upgrade the compiler with only a minor version change or less in the standard library.
It should likewise be possible to upgrade a major version change in the standard library without breaking a compiler.

**Problem 5**: Popular and uncontroversial machinery like ``Text`` not available from the standard library
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There has been much grumbling over the years that popular items like ``Text`` are not in the standard library.
Items like these are expected to be in languages' standard libraries and elsewhere indeed are found there.

Now, it is one thing for a standard library to be minimal, and say not offer any string type or operations on that.
That would not be so bad.
What is worse is that ``base`` does offer ``String``, and furthermore operations on ``String``.
The problem is thus not so much that it is inconvenient to grab the ``Text``-based functionality from elsewhere, as it is that ``base`` has a foot-gun in offering alternatives that should be *avoided*.
Standard libraries which *mislead* the user as to what they ought to do are worse than standard libraries which stay mum altogether.

Solution criteria
^^^^^^^^^^^^^^^^^

Firstly, do not offer bad alternatives in the standard library that users should not use.
Secondarily, do offer good alternatives, like ``Text`` and associated functionality, if they are suitable for inclusion.

.. [#ubiquitous-language]
  Compare the "Ubiquitous Language" concept from Eric Evan's *Domain-driven design* also cited in the GHC modularity paper.

.. [#cpu-leaks]
  The choice of CPU/Arch does leak through when wants to do certain special operations, like atomics that depend on the intricacies of memory models, or data-paralleld "SIMD" instrucitons.
  But these concerns are fairly niche and we can mostly not think about them for the purposes of standard library design.

Prior Art and Related Efforts
-----------------------------

There has been much discussion of these topics before, but to my knowledge this is the first time they have been consolidated together.

A few miscellaneous things:

Rust's ``core`` vs ``std``
~~~~~~~~~~~~~~~~~~~~~~~~~~

Rust also has multiple standard libraries, of which the most notable are ``core`` vs ``std``.
This split solves the portability problem:
Only maximally portable concepts, ones that work everywhere Rust does including embedded/freestanding contexts, can go in ``core``.
The rest must go in ``std``.

However, this doesn't go far enough to address the standard library --- language implementation coupling problem.
Both libraries still live in the compiler repo and are still released in tandem with the compiler.
``core`` also contains numerous definitions that, while perfectly portable, have nothing to do with interfacing the compiler internals.
(Think e.g. the equivalents of things like ``Functor`` and ``Monoid`` for us, perfectly portable across compilation targets, but also implementation-agnostic.)

Rust's ``cap-std``
~~~~~~~~~~~~~~~~~~

`cap-std <https://github.com/bytecodealliance/cap-std>`_ is a Rust library exploring what ergonomic IO interfaces for WASI system calls in a high level language should look like.
On one hand, it is great, and we should borrow from it heavily.
On the other hand, we should surpass it in not needing to be something on top of the "regular" standard library which ordinarily exposes more Unixy things than is appropriate.

Rust's ``std`` and WASI
~~~~~~~~~~~~~~~~~~~~~~~

While the best experience comes from using ``cap-std`` as described above, Rust's ``std`` still makes sure to avoid indirecting through ``wasi-libc`` wherever possible.
`This PR <https://github.com/rust-lang/rust/pull/63676>`_ made that change, using the ``wasi`` library (Rust bindings to WASI system calls) directly.
This is what we should emulate in order to provide a top-tier programming environment for greenfield WebAssembly applications in Haskell.

Technical Roadmap
-----------------

**Step 2**: Split out pure GHC-agnostic libraries from ``ghc-base``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Start splitting out code from GHC base with the goal of creating the innermost IO-free standard library/ies.
Definitions like ``Functor`` require little to no magical builtins (other than the function type), and so are good candidates for pulling out of ``ghc-base``.
Such code should not rely on GHC-specific definitions likely to change between compiler versions.
Conversely, because the code has stable assumptions, it should be able to live in external repos included in GHC as submodules.

``base`` will reexport these libraries as need be.

At the same time, miscellaneous definitions near the "top" of ``base`` that depend on many things but are little-used can also be moved out.
``Eq1`` and friends since https://github.com/haskell/core-libraries-committee/issues/10 are not relied upon by anything else, and so can easily be moved out of ``ghc-base``.
``base`` can reexport these items, but we might consider deprecating that reexport once this is possible (`GHC proposals issue #489 <https://github.com/ghc-proposals/ghc-proposals/discussions/489>` / `GHC Issue #22489 <https://gitlab.haskell.org/ghc/ghc/-/issues/22489>`).
Ultimately ``base`` itself would be deprecated, but pealing out bits of random functionality earlier can help remove definitions from the CLC critical path and chip away at **Problem 2** and **Problem 4**.

There is a basic trade-off here that separating out items that are deeper in the dependency graph is more valuable, but separating out those that are shallower is more valuable.

At the end of this process, there should be one or more libraries that the CLC can consider blessing as a standard library for pure programming.
If we do need few fine-grained libraries to "zig-zag" between GHC-specific and GHC-agnostic definitions, this might be a reexport of a few such libraries to simplify things.

This makes progress on all problems but **Problem 5**.

**Step 3**: Split out libraries for "internal" IO
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Split out libraries from ``ghc-base`` dealing with "internal IO" --- effects that are contained within the program rather than dealing with the outside world.
This would definitions like ``IO`` and ``ST``, ``MVar`` and ``IORef``, ``ForeignPtr``, etc.

Arrays and thus text also come up here.
We should consider reworking the definitions of important libraries like ``array``, ``vector``, ``bytestring``, ``text``, so they can depend just on these libraries and those from the previous step --- intentionally leaving out external IO.
This chips away at **Problem 5**, finally, and allows us to reduce the primacy of ``String``.

Again, the CLC has an opportunity to look at the split out libraries to curate new standard libraries.

**Step 4**: Split out libraries for "external" IO
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Split out libraries from ``ghc-base`` dealing with "external IO" --- interacting with the outside world.

Even within this step, we can think about layering.
As discussed before, Windows and Unix and largely a super set of what WASI offers.

On the other hand, platform-agnostic *abstractions* (as opposed to binding low-level interfaces which are themselves portable) should be done at the highest layer.
Windows versus Unix is a good illustration of this:
Right now, ``base`` relies on MinGW's and Windows's `libc` compat layer to approximate traditional Unix functionality.
The ``unix`` and ``Win32`` layers than expose additional platform-specific functionality.

Quite arguably, this is the wrong way of going about IO.

- It would be nice to make MinGW optional and support Windows more directly/natively.
  This is what Rust does.
  LLVM has made doing so (e.g. without relying on proprietary tools exclusively) much easier in recent years.
  As Ben Gamari and others can attest, the state of Windows support in GNU tools is not good.

- It would be nice to not limit ourselves to a lowest-common-denominator of ``libc``-esque functionality as our starting point.
  Windows and Linux have added all sorts of more modern functionality in recent years that often is (a) similar, and (b) represents better ways to do existing operations, e.g. avoiding around restrictions on character sets, file path length, etc.
  But libc, even in MSVCRT form, is hard to change due to various legacy concerns, and so cannot always take advantage of all of these.

From this perspective we should invert the dependencies:
``unix`` and ``Win32`` should be below, binding Unix and Windows APIs *as they are*,
and then *above* that is a compatibility layer creating portable interfaces with the latest best practice *without* the burden of libc tradition.

``base`` would need to reexport that high level compatibility layer to keep its existing interface, putting it above not below ``unix`` and ``Win32``, unlike today.

One important thing we should do is make the legacy ``String``-based IO methods depend on more performant and preferable array-based ones.
(There are some technical issues where ``String`` can represent invalid unicode that ``Text`` cannot, so I reframe from calling out ``Text`` in particular here.)
This deduplicates work --- no more maintaining very similar code in two different places --- while allowing us to gradually phase out the ``String``-based versions.
This is good for **Problem 5**.

For the WASI parts of this work, the HF should reach out to the `Bytecode Alliance <https://bytecodealliance.org/>`, which is the HF equivalent for WASM and WASI, for financial and technical assistance ensuring the relevant new standard libraries can work well with WASI.

**Step 5**: Also split ``template-haskell``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``template-haskell`` also suffers from the same versioning problem as ``base``.
For issues unrelated to avoiding version churn busywork, in `GHC issue #21738`_ it was already proposed to split up the library.
We should also use low-tech tricks like providing more field names and pattern synonyms to allow writing code that is robust to mild data structure changes.
(The ability to `disallow positional access on data constructors <https://github.com/ghc-proposals/ghc-proposals/discussions/513>` is a medium-effort way to make this more robust.)

Eventually, for the most robust solution, we should tackle `GHC proposal #529`_, which proposing adding language features such that the breakage-prone AST data structures of ``template-haskell`` are way less likely to be used explicitly at all.
If we implement that language feature, then it makes sense to additionally split out ``template-haskell`` for stability's sake, solving the equivalent of **Problem 2** for that library.

.. _`GHC issue #21738`: https://gitlab.haskell.org/ghc/ghc/-/issues/21738
.. _`GHC proposal #529`: https://github.com/ghc-proposals/ghc-proposals/pull/529

Roadmap conclusion
~~~~~~~~~~~~~~~~~~

At this point, ``ghc-base`` should no longer exist, having been entirely split into other libraries.
``base`` should remain all reexports, but of those libraries instead of ``ghc-base``, except for possibly some GHC-agnostic material we wish to deprecate with ``base``.
(Such material can go back to living inside ``base``.)

All such libraries should be rigorously designed to either be GHC-version-specific or GHC-version-agnostic, with few or no definitions of the other sort stuck in the "wrong" library.
Libraries of the former sort should live within the GHC repo, while libraries of the latter sort should live outside of GHC pinned as submodules.
Multiple GHC versions should be able to share the latter libraries at the same version, validating that the interfaces they depend on are indeed GHC-version agnostic.

Multiple libraries of each type are needed because dependency chains "zig-zag" back and forth between the two categories.
For example, the definition of ``Int`` is GHC-specific, the ``Num`` class itself should be GHC-agnostic, and much code using ``+`` is again GHC-specific.

Individual libraries, possibly including reexports from other such libraries, besides ``base``, will be blessed by the CLC as standard libraries the community should use instead of ``base``.

Appendix: What are standard libraries for?
==========================================

*If parts of this proposal seems hard to understand or surprising, background information in the form of the author's critical view on the very concept of a standard library me prove illuminating.*

Synthesis
---------

So if we want to have little libraries for technical reasons, but large feature-rich standard libraries for social reasons, what do we do?
Both!
The original definitions of just about everything be incubated in little libraries, and continue to live in little libraries.
Standard libraries should have very little of their own definitions, but just focus on reexports, their role is not to *invent*, but to *curate*.
Plans today in the works like *moving* ``Profunctor`` to ``base`` should instead become having the new standard libraries merely *depend* on the ``profunctors`` library and reexport items.

In the `words of Shriram Krishnamurthi <https://twitter.com/ShriramKMurthi/status/1597942676560965634>`_, the slogan should not be "batteries included", but "batteries included — but not inserted".
When one just starts up GHCi without arguments, or runs ``cabal new``, one will get the nice feature-rich standard library loaded / as a ``build-depend`` by default,
but tweak a few flags and the cabal stanza, and its easy to remove those sledgehammer deps and just depend on exactly what one needs.

This is not normative!
----------------------

Hopefully the above appendix makes the vision of the proposal author more clear, but it should be equally stressed that this appendix is not normative.
Nowhere is the CLC being told exactly what the new standard libraries should look like.
Nowhere is it also specified how the implementation should be cut up behind the scenes.
But, if this proposal is to succeed, it seems like reaching a consensus position similar to the above compromise between two extremes is likely to be necessary.
